<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Guitar Fretboard Flashcard Game</title>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/vexflow@5.0.0/build/cjs/vexflow.js"></script>
    <style>
      /* Consolidated CSS: duplicates removed; latest definitions kept */
      :root {
        --bg: #222;
        --text: #f2f2f2;
        --accent: #3498db;
        --success: #2ecc40;
        --error: #e74c3c;
        --warning: #f7ca18;
        --secondary-bg: #333;
        --tertiary-bg: #444;
        --inactive: #bbb;
        --border: #666;
        --border-radius: 8px;
        --btn-radius: 12px;
        --small-radius: 5px;
        --font-large: 4em;
        --font-medium: 1.5em;
        --font-normal: 1.2em;
        --font-small: 0.8em;
        --padding: 0.5em;
        --margin: 1em;
        --transition: 0.3s;
        --box-shadow: 0 0 0 5px #2264a7;
      }

      body {
        font-family: sans-serif;
        background: var(--bg);
        color: var(--text);
        margin: 0;
        padding: 0;
      }

      .container {
        max-width: 540px;
        margin: 3em auto 0;
        padding: 2em;
        background: var(--secondary-bg);
        border-radius: var(--border-radius);
      }

      .flashcard {
        text-align: left;
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        margin-bottom: 2em;
      }

      .note-row {
        display: flex;
        align-items: center;
        justify-content: flex-start;
        margin-bottom: 0.2em;
        gap: 0.5em;
        width: 100%;
        flex-wrap: wrap;
      }
      .note-row {
        flex-wrap: nowrap;
        gap: 0.5em;
      }

      .quiz-note-btn {
        background: var(--accent);
        color: var(--text);
        border: none;
        border-radius: var(--btn-radius);
        padding: var(--padding) 1em;
        font-size: var(--font-medium);
        cursor: pointer;
        margin-right: 0.4em;
        box-shadow: var(--box-shadow);
        transition: box-shadow var(--transition);
        flex: 0 0 auto;
        max-width: 140px;
        min-width: 56px;
        box-sizing: border-box;
      }

      #note-score {
        max-width: 260px;
        min-width: 56px;
        height: 100px;
        overflow: visible;
        flex: 0 0 auto;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      #note-score svg {
        background: transparent;
        border-radius: 4px;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        height: 100%;
        width: auto;
        max-width: 100%;
        display: block;
      }
      #treble-score,
      #bass-score {
        overflow: visible;
        display: block;
        background: white;
      }

      .countdown-inline {
        min-width: 2ch;
        font-size: clamp(1.6rem, 3.5vw, var(--font-large));
        font-weight: 700;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0 0.25em;
      }

      .string {
        font-size: var(--font-large);
        flex: 1 1 auto;
        min-width: 0;
        white-space: normal;
        overflow: visible;
        /* text-overflow: ellipsis; */
      }
      .string::before {
        content: "on the ";
      }

      .fretboard-area {
        margin-bottom: 1.5em;
        overflow-x: auto;
      }
      .fretboard-table {
        width: 100%;
        table-layout: fixed;
        border-collapse: separate;
        border-spacing: 0;
        margin: 0;
      }
      .fretboard-table th,
      .fretboard-table td {
        padding: 0;
        margin: 0;
      }
      .fretboard-table th {
        height: 32px;
      }

      .fretboard-table .open-note {
        font-weight: bold;
        font-size: 1.15em;
        width: 48px;
        min-width: 48px;
        text-align: right;
        padding-right: 6px;
        background: var(--bg);
        color: var(--text);
        border-right: 2px solid var(--border);
        cursor: pointer;
        user-select: none;
        white-space: nowrap;
        transition: background var(--transition);
      }
      .fretboard-table .open-note:hover {
        background: #2980b9;
      }
      .fretboard-table .open-note:active {
        background: #1f5582;
      }

      .fretboard-table .fret-label {
        width: auto;
        min-width: 24px;
        height: 32px;
        text-align: center;
        font-size: 0.85em;
        color: var(--inactive);
        box-sizing: border-box;
      }
      .fretboard-table .fret-dot-cell {
        width: auto;
        min-width: 24px;
        height: 28px;
        text-align: center;
        padding: 0;
        box-sizing: border-box;
      }

      .fretboard-table .fret-cell {
        width: auto;
        min-width: 28px;
        height: 28px;
        border: 1px solid var(--border);
        background: var(--bg);
        cursor: pointer;
        text-align: center;
        vertical-align: middle;
        transition: background var(--transition);
        position: relative;
        box-sizing: border-box;
      }
      .fretboard-table .fret-cell.inactive {
        opacity: 0.5;
        cursor: default;
      }
      .fretboard-table .fret-cell.active-string {
        background: #888;
        color: var(--bg);
      }
      .fretboard-table .fret-cell.fret-found {
        background: var(--success) !important;
        color: var(--text);
      }
      .fretboard-table .fret-cell.fret-wrong {
        background: var(--error) !important;
      }
      .fretboard-table .fret-cell.open-fret {
        background: var(--warning);
        color: var(--bg);
        font-weight: bold;
      }

      .fretboard-table .fret-dot {
        display: inline-block;
        width: 14px;
        height: 14px;
        background: #e2e2e2;
        border-radius: 50%;
        margin: 7px auto 0;
      }
      .fretboard-table .fret-dot.double {
        height: 30px;
        width: 14px;
        background: none;
        position: relative;
        top: 0;
      }
      .fretboard-table .fret-dot.double .dot {
        width: 12px;
        height: 12px;
        background: #e2e2e2;
        border-radius: 50%;
        position: absolute;
        left: 4px;
      }
      .fretboard-table .fret-dot.double .dot1 {
        top: 4px;
      }
      .fretboard-table .fret-dot.double .dot2 {
        top: 18px;
      }

      .fretboard-table .fretboard-header {
        background: var(--secondary-bg);
      }
      .fretboard-table .fretboard-mark-row td {
        background: var(--secondary-bg);
      }
      .fretboard-table .open-note-row td {
        height: 28px;
      }

      .fret-buttons {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(50px, 1fr));
        gap: 0.5em;
        justify-content: center;
        margin-bottom: var(--margin);
      }
      .fret-btn {
        background: var(--tertiary-bg);
        border: none;
        color: var(--text);
        font-size: var(--font-medium);
        padding: var(--padding) 1em;
        border-radius: var(--small-radius);
        cursor: pointer;
        transition: background var(--transition);
        text-align: center;
      }
      .fret-btn.correct {
        background: var(--success);
      }
      .fret-btn.wrong {
        background: var(--error);
      }
      .fret-btn.open-fret {
        background: var(--warning);
        color: var(--bg);
        font-weight: bold;
      }

      .options {
        margin-bottom: var(--margin);
        display: flex;
        flex-direction: column;
        gap: 0.4em;
      }
      .play-btn {
        background: var(--accent);
        color: var(--text);
        border: none;
        border-radius: var(--small-radius);
        padding: var(--padding) 1.1em;
        font-size: var(--font-normal);
        cursor: pointer;
        margin-top: var(--margin);
      }

      .config {
        margin-bottom: var(--margin);
      }
      .config-table,
      .tuning-container {
        width: 100%;
      }
      .config-table {
        border-collapse: collapse;
      }
      .config-table td {
        padding: var(--padding) 0;
      }

      .tuning-container {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 1em;
      }
      .string-config {
        padding: 0.8em;
        border: 1px solid var(--border);
        border-radius: var(--small-radius);
        flex: 1 1 200px;
        min-width: 200px;
      }
      .string-label {
        font-weight: bold;
        margin-bottom: 0.5em;
        display: block;
      }
      .string-controls {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 0.5em;
        align-items: center;
      }
      .control-row {
        display: flex;
        align-items: center;
        gap: 0.5em;
      }
      .control-row span {
        min-width: 3em;
        font-size: var(--font-small);
      }
      .tuning-select,
      .octave-select {
        margin: 0;
        font-size: var(--font-normal);
        padding: var(--padding);
        min-width: 4em;
      }

      .sound-enable-banner {
        background: var(--error);
        color: var(--text);
        padding: var(--padding) 1em;
        text-align: center;
        margin-bottom: var(--margin);
        border-radius: var(--small-radius);
        cursor: pointer;
        font-size: var(--font-normal);
        font-weight: bold;
        display: none;
      }
      .sound-enable-banner:hover {
        background: #c0392b;
      }
      .sound-enable-banner.enabled {
        background: var(--success);
      }

      .flashcard-instruction {
        font-size: var(--font-normal);
        color: var(--inactive);
        margin-bottom: var(--margin);
        align-self: flex-start;
      }
      .timeout-input {
        width: 4em;
      }
      .copyright {
        text-align: center;
        font-size: var(--font-small);
        margin-top: 2em;
        color: var(--inactive);
      }
      .small-comment-text {
        font-size: var(--font-small);
        color: var(--inactive);
      }

      #skip-countdown {
        display: none;
        background: var(--accent);
        color: var(--text);
        border: none;
        border-radius: var(--btn-radius);
        padding: var(--padding) 0.5em;
        font-size: var(--font-medium);
        cursor: pointer;
        margin-left: 0.5em;
        box-shadow: var(--box-shadow);
        transition: box-shadow var(--transition);
      }

      .countdown-inline:not(:empty) + #skip-countdown {
        display: inline-flex;
      }

      @media (max-width: 600px) {
        .container {
          padding: var(--padding);
        }
        .note-row {
          gap: var(--padding);
        }
        .quiz-note-btn {
          font-size: 2em;
          padding: 0.6em 1.2em;
        }
        .countdown-inline {
          font-size: 2em;
          min-width: 1.6em;
        }
        .string {
          font-size: 2em;
        }
        .fret-btn {
          font-size: 1em;
          padding: 0.4em 0.6em;
        }
        .config-table td {
          font-size: var(--font-normal);
          padding: 0.8em 0;
        }
        .string-config {
          font-size: var(--font-normal);
          padding: 0.8em 0;
          border: none;
          border-bottom: 1px solid var(--border);
          border-radius: 0;
          flex: 1 1 100%;
          min-width: 100%;
        }
        .tuning-container {
          flex-direction: column;
        }
        .string-controls {
          flex-direction: column;
          align-items: flex-start;
        }
        .control-row {
          width: 100%;
          justify-content: flex-start;
        }
        input[type="checkbox"] {
          width: 1.5em;
          height: 1.5em;
          margin-right: var(--padding);
        }
        input[type="number"],
        select {
          font-size: var(--font-normal);
          padding: var(--padding);
          margin-left: var(--padding);
          width: auto;
          min-width: 4em;
        }
        .tuning-select,
        .octave-select {
          font-size: var(--font-normal);
          padding: var(--padding);
          width: auto;
          min-width: 4em;
          margin: 0;
        }
        .config-table td select,
        .config-table td input[type="number"],
        .config-table td .tuning-select {
          display: inline-block;
          margin-top: 0.5em;
        }
        button {
          font-size: var(--font-normal);
          padding: 0.6em 1em;
          margin-top: var(--padding);
        }
        label {
          font-size: var(--font-normal);
          margin-bottom: var(--padding);
        }
        .flashcard-instruction {
          margin-bottom: var(--padding);
        }
      }

      @media (min-width: 601px) {
        .container {
          max-width: 100%;
        }
        .quiz-note-btn {
          font-size: clamp(1.8rem, 3.2vw, var(--font-large));
        }
        .fret-btn {
          text-align: center;
          padding: var(--padding) 0.5em;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div id="sound-banner" class="sound-enable-banner">🔊 Click here to enable sound</div>
      <div class="flashcard">
        <div class="flashcard-instruction">Find the note</div>
        <div class="note-row">
          <button class="quiz-note-btn" id="quiz-note-btn" title="Play this note">?</button>
          <div class="string" id="flashcard-string">?</div>
          <span class="countdown-inline" id="countdown"></span>
          <button class="countdown-skip" id="skip-countdown" title="Skip to next quiz">⏭️</button>
          <div id="note-score">
            <div id="treble-score"></div>
            <div id="bass-score"></div>
          </div>
        </div>
        <div class="fretboard-area" id="fretboard-area"></div>
      </div>
      <div class="fret-buttons" id="fret-buttons"></div>
      <div class="options">
        <label>
          <input type="checkbox" id="extended-range" />
          24 frets (2-3 notes to find)
        </label>
        <label>
          <input type="checkbox" id="accidentals" />
          Include accidentals: sharps (♯) and flats (♭)
        </label>
        <label>
          <input type="checkbox" id="enable-bias" />
          Bias towards strings with mistakes
        </label>
        <label>
          <input type="checkbox" id="show-score-notation" />
          Show score notation
        </label>
        <div class="config">
          <table class="config-table">
            <tr>
              <td>
                Next question after (seconds):
                <select id="timeout-seconds">
                  <option value="0">0</option>
                  <option value="1">1</option>
                  <option value="2" selected>2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                  <option value="6">6</option>
                  <option value="7">7</option>
                  <option value="8">8</option>
                  <option value="9">9</option>
                  <option value="10">10</option>
                </select>
              </td>
            </tr>
            <tr id="score-key-row" style="display: none">
              <td>
                Score key (experimental, unstable):
                <select id="score-key">
                  <option value="C">C maj / A min</option>
                  <option value="G">G maj / E min</option>
                  <option value="D">D maj / B min</option>
                  <option value="A">A maj / F♯ min</option>
                  <option value="E">E maj / C♯ min</option>
                  <option value="B">B maj / G♯ min</option>
                  <option value="F#">F♯ maj / D♯ min</option>
                  <option value="C#">C♯ maj / A♯ min</option>
                  <option value="F">F maj / D min</option>
                  <option value="Bb">B♭ maj / G min</option>
                  <option value="Eb">E♭ maj / C min</option>
                  <option value="Ab">A♭ maj / F min</option>
                  <option value="Db">D♭ maj / B♭ min</option>
                  <option value="Gb">G♭ maj / E♭ min</option>
                  <option value="Cb">C♭ maj / A♭ min</option>
                </select>
              </td>
            </tr>
            <tr>
              <td>
                Number of strings:
                <select id="num-strings">
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="5">5</option>
                  <option value="6" selected>6</option>
                  <option value="7">7</option>
                  <option value="8">8</option>
                  <option value="9">9</option>
                  <option value="10">10</option>
                  <!-- <option value="11">11</option>
                  <option value="12">12</option> -->
                </select>
              </td>
            </tr>
            <tr id="tuning-config">
              <td>
                <!-- Dynamically populated with tuning table -->
              </td>
            </tr>
            <tr>
              <td>
                <button id="reset-tuning">Reset to Standard Tuning</button>
              </td>
            </tr>
            <tr>
              <td>
                <button id="reset-stats">Reset stats (0)</button>
              </td>
            </tr>
          </table>
        </div>
      </div>
      <div class="small-comment-text">Inspired by Steve Vai's anecdote about the first homework given to him by Joe Satriani: "learn all notes on the fretboard".</div>
    </div>
    <div class="copyright">
      Copyright &copy; 2025 Github copilot and Dmitry Ledentsov |
      <a href="https://github.com/d-led/fret-flashcards" target="_blank" style="color: var(--accent); text-decoration: none">GitHub</a>
    </div>
    <script>
      const SETTINGS_KEY = "guitar_flashcard_settings_v1";
      const STATS_KEY = "guitar_flashcard_stats_v1";

      const naturalNotes = ["C", "D", "E", "F", "G", "A", "B"];
      const allNotes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
      const flatNotes = ["Db", "Eb", "Gb", "Ab", "Bb"];
      const sharpNotes = ["C#", "D#", "F#", "G#", "A#"];
      const noteVariants = [
        { name: "C", idx: 0 },
        { name: "C#", idx: 1 },
        { name: "Db", idx: 1 },
        { name: "D", idx: 2 },
        { name: "D#", idx: 3 },
        { name: "Eb", idx: 3 },
        { name: "E", idx: 4 },
        { name: "F", idx: 5 },
        { name: "F#", idx: 6 },
        { name: "Gb", idx: 6 },
        { name: "G", idx: 7 },
        { name: "G#", idx: 8 },
        { name: "Ab", idx: 8 },
        { name: "A", idx: 9 },
        { name: "A#", idx: 10 },
        { name: "Bb", idx: 10 },
        { name: "B", idx: 11 },
      ];

      // Independent octave shift (in semitones) applied when writing notation for each clef.
      // Adjust these to control where notes appear on the staff for treble and bass independently.
      let trebleOctaveShift = 12; // conventional guitar treble is written an octave higher
      let bassOctaveShift = 12; // bass clef notes written 3 octaves up for proper bass guitar notation

      function renderNoteScore(note, stringIndex, frets) {
        const trebleContainer = document.getElementById("treble-score");
        const bassContainer = document.getElementById("bass-score");

        // Completely clear and reset containers
        trebleContainer.innerHTML = "";
        bassContainer.innerHTML = "";
        trebleContainer.removeAttribute("style");
        bassContainer.removeAttribute("style");

        if (!note || !frets || frets.length === 0) return;

        console.log("renderNoteScore - Quiz note:", note, "String:", stringIndex, "Frets:", frets);
        console.log("String tuning:", tuning[stringIndex]);

        // Calculate the actual notes and octaves for each fret position (sounding midi)
        const openMidi = getMidi(tuning[stringIndex].note, tuning[stringIndex].octave);
        console.log("Open MIDI:", openMidi);

        // Staff MIDI ranges heuristic (to minimize ledger lines)
        // Extended ranges to show notes in both clefs when appropriate
        const TREBLE_MIN = 40; // ~E2 (extended down for 8-string guitar low notes)
        const TREBLE_MAX = 127; // Open upwards for high notes
        const BASS_MIN = 0; // Open downwards for low notes
        const BASS_MAX = 91; // ~G6 (written 3 octaves up from G3)

        const trebleNotes = [];
        const bassNotes = [];

        for (let f of frets) {
          const midi = openMidi + f; // sounding midi
          console.log(`Fret ${f}: sounding MIDI ${midi}`);

          // For notation, apply independent octave shifts per clef so we can control written pitch separately
          const writtenTrebleMidi = midi + trebleOctaveShift;
          const writtenBassMidi = midi + bassOctaveShift;

          // Check if notes fit well in each clef (within staff range without too many ledger lines)
          const trebleFits = writtenTrebleMidi >= TREBLE_MIN && writtenTrebleMidi <= TREBLE_MAX;
          const bassFits = writtenBassMidi >= BASS_MIN && writtenBassMidi <= BASS_MAX;

          console.log(`Fret ${f}: trebleFits=${trebleFits}, bassFits=${bassFits}, writtenTreble=${writtenTrebleMidi}, writtenBass=${writtenBassMidi}`);

          // Logic for determining which clef(s) to use:
          // For bass guitar range (sounding MIDI up to G3 on 3rd string), prefer bass clef
          // For higher guitar range, prefer treble clef
          // Show both if the note fits well in both ranges

          if (midi <= 55 && bassFits) {
            // Low to mid range - prefer bass clef
            const { note: bName, octave: bOct } = midiToNoteAndOctave(writtenBassMidi, note);
            let vexB = bName.toLowerCase();
            if (bName.includes("#")) vexB = bName.charAt(0).toLowerCase() + "#";
            else if (bName.includes("b")) vexB = bName.charAt(0).toLowerCase() + "b";
            const bPair = { note: vexB, octave: bOct };
            if (!bassNotes.some((n) => n.note === bPair.note && n.octave === bPair.octave)) bassNotes.push(bPair);

            // Also add to treble if it fits well (for comparison)
            if (trebleFits) {
              // Show treble clef for all notes that fit well
              const { note: tName, octave: tOct } = midiToNoteAndOctave(writtenTrebleMidi, note);
              let vexT = tName.toLowerCase();
              if (tName.includes("#")) vexT = tName.charAt(0).toLowerCase() + "#";
              else if (tName.includes("b")) vexT = tName.charAt(0).toLowerCase() + "b";
              const tPair = { note: vexT, octave: tOct };
              if (!trebleNotes.some((n) => n.note === tPair.note && n.octave === tPair.octave)) trebleNotes.push(tPair);
            }
          } else if (midi > 55 && trebleFits) {
            // High range - prefer treble clef
            const { note: tName, octave: tOct } = midiToNoteAndOctave(writtenTrebleMidi, note);
            let vexT = tName.toLowerCase();
            if (tName.includes("#")) vexT = tName.charAt(0).toLowerCase() + "#";
            else if (tName.includes("b")) vexT = tName.charAt(0).toLowerCase() + "b";
            const tPair = { note: vexT, octave: tOct };
            if (!trebleNotes.some((n) => n.note === tPair.note && n.octave === tPair.octave)) trebleNotes.push(tPair);
          } else {
            // Fallback: choose the clef that minimizes ledger lines
            const distToRange = (m, min, max) => {
              if (m >= min && m <= max) return 0;
              if (m < min) return min - m;
              return m - max;
            };

            const trebleDist = distToRange(writtenTrebleMidi, TREBLE_MIN, TREBLE_MAX);
            const bassDist = distToRange(writtenBassMidi, BASS_MIN, BASS_MAX);

            let targetWrittenMidi, targetClef;
            if (bassDist < trebleDist) {
              targetWrittenMidi = writtenBassMidi;
              targetClef = "bass";
            } else {
              targetWrittenMidi = writtenTrebleMidi;
              targetClef = "treble";
            }

            const { note: displayNoteName, octave } = midiToNoteAndOctave(targetWrittenMidi, note);
            console.log(`Fret ${f}: chosen clef ${targetClef}, written MIDI ${targetWrittenMidi}, note ${displayNoteName}${octave}`);

            let vexNote = displayNoteName.toLowerCase();
            if (displayNoteName.includes("#")) {
              vexNote = displayNoteName.charAt(0).toLowerCase() + "#";
            } else if (displayNoteName.includes("b")) {
              vexNote = displayNoteName.charAt(0).toLowerCase() + "b";
            }

            const pair = { note: vexNote, octave: octave };

            if (targetClef === "treble") {
              if (!trebleNotes.some((n) => n.note === pair.note && n.octave === pair.octave)) trebleNotes.push(pair);
            } else {
              if (!bassNotes.some((n) => n.note === pair.note && n.octave === pair.octave)) bassNotes.push(pair);
            }
          }
        }

        console.log("Treble notes:", trebleNotes);
        console.log("Bass notes:", bassNotes);

        // Create note objects for VexFlow with explicit clef specification, matching library test style
        const trebleNoteObj = trebleNotes.length > 0 ? { keys: trebleNotes.map((n) => `${n.note}/${n.octave}`), clef: "treble", duration: "w", stemDirection: 1 } : null;
        const bassNoteObj = bassNotes.length > 0 ? { keys: bassNotes.map((n) => `${n.note}/${n.octave}`), clef: "bass", duration: "w", stemDirection: -1 } : null;

        console.log("Final treble note object:", trebleNoteObj);
        console.log("Final bass note object:", bassNoteObj);

        const width = note.includes("#") || note.includes("b") ? 140 : 120;

        // Create and render staves only when there are notes for that clef
        // (avoid rendering empty staff glyphs when no notes are present)
        if (trebleNotes.length > 0) {
          try {
            const factoryTreble = new VexFlow.Factory({
              renderer: { elementId: "treble-score", width: width, height: 100 },
            });

            const scoreTreble = factoryTreble.EasyScore();
            const systemTreble = factoryTreble.System();

            console.log("Rendering treble notes:", trebleNoteObj);

            // Defensive: don't attempt to create a voice from an empty array
            if (!trebleNoteObj) {
              console.warn("Skipping treble render: no notes");
            } else {
              const trebleStaveNote = factoryTreble.StaveNote(trebleNoteObj);
              const voiceTreble = scoreTreble.voice([trebleStaveNote]);
              // Defensive: ensure voiceTreble appears valid before formatting/drawing
              if (!voiceTreble || typeof voiceTreble.getTickables !== "function") {
                console.warn("Invalid treble voice, skipping draw", voiceTreble);
              } else {
                voiceTreble.setMode(VexFlow.Voice.Mode.SOFT);
                systemTreble
                  .addStave({ voices: [voiceTreble] })
                  .addClef("treble")
                  .addKeySignature(scoreKey);

                factoryTreble.draw();
                const trebleSvg = document.getElementById("treble-score").querySelector("svg");
                if (trebleSvg) {
                  // Remove the white background rect added by VexFlow to eliminate extra white space
                  const bgRect = trebleSvg.querySelector("rect");
                  if (bgRect) bgRect.remove();
                  // Calculate tight bounding box around stave and notes
                  const staveG = trebleSvg.querySelector("g.vf-stave");
                  const noteG = trebleSvg.querySelector("g.vf-stavenote");
                  let minX = Infinity,
                    minY = Infinity,
                    maxX = -Infinity,
                    maxY = -Infinity;
                  if (staveG) {
                    const b = staveG.getBBox();
                    minX = Math.min(minX, b.x);
                    minY = Math.min(minY, b.y);
                    maxX = Math.max(maxX, b.x + b.width);
                    maxY = Math.max(maxY, b.y + b.height);
                  }
                  if (noteG) {
                    const rect = noteG.querySelector("rect");
                    if (rect) {
                      const x = parseFloat(rect.getAttribute("x"));
                      const y = parseFloat(rect.getAttribute("y"));
                      const width = parseFloat(rect.getAttribute("width"));
                      const height = parseFloat(rect.getAttribute("height"));
                      minX = Math.min(minX, x);
                      minY = Math.min(minY, y);
                      maxX = Math.max(maxX, x + width);
                      maxY = Math.max(maxY, y + height);
                    }
                  }
                  if (minX !== Infinity) {
                    const margin = 24;
                    trebleSvg.setAttribute("viewBox", `${minX - margin} ${minY - margin} ${maxX - minX + 2 * margin} ${maxY - minY + 2 * margin}`);
                  } else {
                    // Fallback
                    const bbox = trebleSvg.getBBox();
                    trebleSvg.setAttribute("viewBox", `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);
                  }
                  trebleSvg.setAttribute("width", "100%");
                  trebleSvg.setAttribute("height", "100%");
                }
              }
            }
          } catch (err) {
            console.error("Error rendering treble staff:", err, "\ntrebleNoteObj=", trebleNoteObj, "\ntrebleNotes=", trebleNotes);
          }
        }

        if (bassNotes.length > 0) {
          try {
            const factoryBass = new VexFlow.Factory({
              renderer: { elementId: "bass-score", width: width, height: 100 },
            });

            const scoreBass = factoryBass.EasyScore();
            const systemBass = factoryBass.System();

            console.log("Rendering bass notes:", bassNoteObj);

            if (!bassNoteObj) {
              console.warn("Skipping bass render: no notes");
            } else {
              const bassStaveNote = factoryBass.StaveNote(bassNoteObj);
              const voiceBass = scoreBass.voice([bassStaveNote]);
              if (!voiceBass || typeof voiceBass.getTickables !== "function") {
                console.warn("Invalid bass voice, skipping draw", voiceBass);
              } else {
                voiceBass.setMode(VexFlow.Voice.Mode.SOFT);
                systemBass
                  .addStave({ voices: [voiceBass] })
                  .addClef("bass")
                  .addKeySignature(scoreKey);

                factoryBass.draw();
                const bassSvg = document.getElementById("bass-score").querySelector("svg");
                if (bassSvg) {
                  // Remove the white background rect added by VexFlow to eliminate extra white space and pessimize the bounding box
                  const bgRect = bassSvg.querySelector("rect");
                  if (bgRect) bgRect.remove();
                  // Calculate tight bounding box around stave and notes
                  const staveG = bassSvg.querySelector("g.vf-stave");
                  const noteG = bassSvg.querySelector("g.vf-stavenote");
                  let minX = Infinity,
                    minY = Infinity,
                    maxX = -Infinity,
                    maxY = -Infinity;
                  if (staveG) {
                    const b = staveG.getBBox();
                    minX = Math.min(minX, b.x);
                    minY = Math.min(minY, b.y);
                    maxX = Math.max(maxX, b.x + b.width);
                    maxY = Math.max(maxY, b.y + b.height);
                  }
                  if (noteG) {
                    const rect = noteG.querySelector("rect");
                    if (rect) {
                      const x = parseFloat(rect.getAttribute("x"));
                      const y = parseFloat(rect.getAttribute("y"));
                      const width = parseFloat(rect.getAttribute("width"));
                      const height = parseFloat(rect.getAttribute("height"));
                      minX = Math.min(minX, x);
                      minY = Math.min(minY, y);
                      maxX = Math.max(maxX, x + width);
                      maxY = Math.max(maxY, y + height);
                    }
                  }
                  if (minX !== Infinity) {
                    const margin = 15;
                    bassSvg.setAttribute("viewBox", `${minX - margin} ${minY - margin} ${maxX - minX + 2 * margin} ${maxY - minY + 2 * margin}`);
                  } else {
                    // Fallback
                    const bbox = bassSvg.getBBox();
                    bassSvg.setAttribute("viewBox", `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);
                  }
                  bassSvg.setAttribute("width", "100%");
                  bassSvg.setAttribute("height", "100%");
                }
              }
            }
          } catch (err) {
            console.error("Error rendering bass staff:", err, "\nbassNoteObj=", bassNoteObj, "\nbassNotes=", bassNotes);
          }
        }
      }

      const typicalFretMarks = [3, 5, 7, 9, 12, 15, 17, 19, 21, 24];
      const doubleFretMarkers = [12, 24];

      let currentCard = null;
      let extendedRange = false;
      let showAccidentals = false;
      let timeoutSeconds = 2;
      let pendingTimeout = null;
      let session = [];
      let sessionIdx = 0;
      let foundFrets = [];
      let countdownInterval = null;
      let countdownValue = 0;
      let fretCount = 12; // default: 0th + frets 1-11

      // Declare stringNames as an empty array (was missing, causing UI breakage)
      let stringNames = [];

      // Add new variables for configurable strings and tuning
      let numStrings = 6;

      // Default tunings for different string counts (expanded to 3-12)
      const defaultTunings = {
        3: {
          name: "Kids guitar",
          strings: [
            { note: "E", octave: 4 },
            { note: "B", octave: 3 },
            { note: "G", octave: 3 },
          ],
        },
        4: {
          name: "Mandolin",
          strings: [
            { note: "E", octave: 4 },
            { note: "A", octave: 3 },
            { note: "D", octave: 3 },
            { note: "G", octave: 2 },
          ],
        },
        5: {
          name: "Open G",
          strings: [
            { note: "D", octave: 4 },
            { note: "B", octave: 3 },
            { note: "G", octave: 3 },
            { note: "D", octave: 3 },
            { note: "G", octave: 2 },
          ],
        },
        6: {
          name: "Standard",
          strings: [
            { note: "E", octave: 4 },
            { note: "B", octave: 3 },
            { note: "G", octave: 3 },
            { note: "D", octave: 3 },
            { note: "A", octave: 2 },
            { note: "E", octave: 2 },
          ],
        },
        7: {
          name: "7-String Standard",
          strings: [
            { note: "E", octave: 4 },
            { note: "B", octave: 3 },
            { note: "G", octave: 3 },
            { note: "D", octave: 3 },
            { note: "A", octave: 2 },
            { note: "E", octave: 2 },
            { note: "B", octave: 2 },
          ],
        },
        8: {
          name: "8-String Standard",
          strings: [
            { note: "E", octave: 4 },
            { note: "B", octave: 3 },
            { note: "G", octave: 3 },
            { note: "D", octave: 3 },
            { note: "A", octave: 2 },
            { note: "E", octave: 2 },
            { note: "B", octave: 2 },
            { note: "F#", octave: 2 },
          ],
        },
        9: {
          name: "9-String Standard",
          strings: [
            { note: "E", octave: 4 },
            { note: "B", octave: 3 },
            { note: "G", octave: 3 },
            { note: "D", octave: 3 },
            { note: "A", octave: 2 },
            { note: "E", octave: 2 },
            { note: "B", octave: 2 },
            { note: "F#", octave: 2 },
            { note: "C#", octave: 1 },
          ],
        },
        10: {
          name: "10-String Standard",
          strings: [
            { note: "E", octave: 4 },
            { note: "B", octave: 3 },
            { note: "G", octave: 3 },
            { note: "D", octave: 3 },
            { note: "A", octave: 2 },
            { note: "E", octave: 2 },
            { note: "B", octave: 2 },
            { note: "F#", octave: 2 },
            { note: "C#", octave: 1 },
            { note: "G#", octave: 1 },
          ],
        },
        11: {
          name: "11-String Standard",
          strings: [
            { note: "E", octave: 4 },
            { note: "B", octave: 3 },
            { note: "G", octave: 3 },
            { note: "D", octave: 3 },
            { note: "A", octave: 2 },
            { note: "E", octave: 2 },
            { note: "B", octave: 2 },
            { note: "F#", octave: 2 },
            { note: "C#", octave: 1 },
            { note: "G#", octave: 1 },
            { note: "D#", octave: 1 },
          ],
        },
        12: {
          name: "12-String Standard",
          strings: [
            { note: "E", octave: 4 },
            { note: "B", octave: 3 },
            { note: "G", octave: 3 },
            { note: "D", octave: 3 },
            { note: "A", octave: 2 },
            { note: "E", octave: 2 },
            { note: "B", octave: 2 },
            { note: "F#", octave: 2 },
            { note: "C#", octave: 1 },
            { note: "G#", octave: 1 },
            { note: "D#", octave: 1 },
            { note: "A#", octave: 1 },
          ],
        },
      };

      let tuning = defaultTunings[6].strings.slice(); // Initialize from defaultTunings to avoid duplication

      let statistics = {
        answers: [],
      }; // Object to hold answer events in 'answers' array

      let enableBias = true; // Default to true for improved learning
      let showScoreNotation = false; // Default to false to hide score by default
      let scoreKey = "C"; // Default key for score notation

      // Octaves for MIDI calculation based on string count (expanded to 3-12)
      // Removed: now combined into defaultTunings

      // Function to calculate MIDI from note and octave
      function getMidi(note, octave) {
        const baseMidi = {
          C: 0,
          "C#": 1,
          Db: 1,
          D: 2,
          "D#": 3,
          Eb: 3,
          E: 4,
          F: 5,
          "F#": 6,
          Gb: 6,
          G: 7,
          "G#": 8,
          Ab: 8,
          A: 9,
          "A#": 10,
          Bb: 10,
          B: 11,
        };
        return 12 * (octave + 1) + baseMidi[note];
      }

      // Function to convert MIDI back to note name and octave, preserving the quiz note preference
      function midiToNoteAndOctave(midi, quizNote) {
        const octave = Math.floor(midi / 12) - 1;
        const noteIndex = midi % 12;

        console.log(`midiToNoteAndOctave: midi=${midi}, noteIndex=${noteIndex}, quizNote=${quizNote}`);

        // Find the correct note name that matches the quiz note preference
        let noteName;
        if (quizNote && quizNote.includes("b")) {
          // Prefer flat notation if quiz note is flat
          const flatVariant = noteVariants.find((nv) => nv.idx === noteIndex && nv.name.includes("b"));
          noteName = flatVariant ? flatVariant.name : allNotes[noteIndex];
          console.log(`Using flat preference: flatVariant=${flatVariant ? flatVariant.name : "none"}, final=${noteName}`);
        } else if (quizNote && quizNote.includes("#")) {
          // Prefer sharp notation if quiz note is sharp
          const sharpVariant = noteVariants.find((nv) => nv.idx === noteIndex && nv.name.includes("#"));
          noteName = sharpVariant ? sharpVariant.name : allNotes[noteIndex];
          console.log(`Using sharp preference: sharpVariant=${sharpVariant ? sharpVariant.name : "none"}, final=${noteName}`);
        } else {
          // Use natural note or default to sharp if no preference
          noteName = allNotes[noteIndex];
          console.log(`Using default: ${noteName}`);
        }

        console.log(`midiToNoteAndOctave result: ${noteName}${octave}`);
        return { note: noteName, octave: octave };
      }

      // Update saveSettings to include new config
      function saveSettings() {
        const settings = {
          extendedRange: !!extendedRange,
          showAccidentals: !!showAccidentals,
          timeoutSeconds: Number(timeoutSeconds),
          numStrings: Number(numStrings),
          tuning: tuning.slice(),
          enableBias: !!enableBias,
          showScoreNotation: !!showScoreNotation,
          scoreKey: scoreKey,
        };
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
      }

      // Update loadSettings to load new config (adjusted validation for 3-12)
      function loadSettings() {
        try {
          const raw = localStorage.getItem(SETTINGS_KEY);
          if (!raw) return;
          const settings = JSON.parse(raw);
          if (typeof settings !== "object") return;
          if ("extendedRange" in settings) {
            extendedRange = !!settings.extendedRange;
            $("#extended-range").prop("checked", extendedRange);
          }
          if ("showAccidentals" in settings) {
            showAccidentals = !!settings.showAccidentals;
            $("#accidentals").prop("checked", showAccidentals);
          }
          if ("timeoutSeconds" in settings) {
            let val = Number(settings.timeoutSeconds);
            if (isFinite(val) && val >= 0 && val <= 10) {
              timeoutSeconds = val;
              $("#timeout-seconds").val(timeoutSeconds);
            }
          }
          if ("numStrings" in settings) {
            let val = Number(settings.numStrings);
            if (val >= 3 && val <= 10) {
              numStrings = val;
              $("#num-strings").val(numStrings);
            }
          }
          if ("tuning" in settings && Array.isArray(settings.tuning) && settings.tuning.length === numStrings) {
            // Validate that each tuning element has note and octave
            if (settings.tuning.every((t) => t && typeof t.note === "string" && typeof t.octave === "number")) {
              tuning = settings.tuning.slice();
            } else {
              tuning = defaultTunings[numStrings].strings.slice();
            }
          } else {
            tuning = defaultTunings[numStrings].strings.slice();
          }
          if ("enableBias" in settings) {
            enableBias = !!settings.enableBias;
            $("#enable-bias").prop("checked", enableBias);
          } else {
            $("#enable-bias").prop("checked", enableBias); // Ensure default true is reflected
          }
          if ("showScoreNotation" in settings) {
            showScoreNotation = !!settings.showScoreNotation;
            $("#show-score-notation").prop("checked", showScoreNotation);
            if (showScoreNotation) {
              $("#score-key-row").show();
            } else {
              $("#score-key-row").hide();
            }
          }
          if ("scoreKey" in settings) {
            scoreKey = settings.scoreKey;
            $("#score-key").val(scoreKey);
          }
        } catch (e) {}
      }

      // Function to save statistics to localStorage
      function saveStatistics() {
        localStorage.setItem(STATS_KEY, JSON.stringify(statistics));
        updateStatsButton(); // Update button after saving
      }

      // Function to load statistics from localStorage
      function loadStatistics() {
        try {
          const raw = localStorage.getItem(STATS_KEY);
          if (raw) {
            const parsed = JSON.parse(raw);
            if (Array.isArray(parsed)) {
              // Backward compatibility: if old data is an array, wrap it in object
              statistics = { answers: parsed };
            } else if (parsed && typeof parsed === "object" && Array.isArray(parsed.answers)) {
              statistics = parsed;
            } else {
              statistics = { answers: [] };
            }
          }
        } catch (e) {
          statistics = { answers: [] };
        }
        updateStatsButton(); // Update button after loading
        computeStringErrorCounts(); // Compute after loading stats
      }

      // Function to update the reset stats button text
      function updateStatsButton() {
        const count = statistics.answers.length;
        $("#reset-stats").text(`Reset stats (${count})`);
      }

      function midiToFreq(midi) {
        return 440 * Math.pow(2, (midi - 69) / 12);
      }

      function getNoteIdxAtFret(stringIdx, fretIdx) {
        const openIdx = allNotes.indexOf(stringNames[stringIdx].openNote);
        return (openIdx + fretIdx) % 12;
      }

      function notesToSet() {
        if (showAccidentals) {
          return allNotes.concat(flatNotes);
        }
        return naturalNotes;
      }

      // Return English ordinal for a positive integer (1 -> "1st", 2 -> "2nd", 11 -> "11th", etc.)
      function getOrdinal(n) {
        const s = ["th", "st", "nd", "rd"];
        const v = n % 100;
        return n + (s[(v - 20) % 10] || s[v] || s[0]);
      }

      function makeSession() {
        // Set correct fret count: open string + 11 frets in default, +24 in extended
        fretCount = extendedRange ? 25 : 12;
        // Dynamically build stringNames based on numStrings and tuning
        stringNames.length = 0; // Clear existing
        for (let i = 0; i < numStrings; i++) {
          let midi = getMidi(tuning[i].note, tuning[i].octave);
          const num = i + 1;
          const ord = getOrdinal(num); // e.g. "1st"
          let name = `${ord}`;
          stringNames.push({ name, openNote: tuning[i].note, midi });
        }
        session = [];
        let notes = notesToSet();
        let frets = [...Array(fretCount).keys()]; // 0 ... 11 or 0 ... 24
        for (let s = 0; s < stringNames.length; s++) {
          for (let n of notes) {
            let idxs = [];
            let openIdx = allNotes.indexOf(stringNames[s].openNote);
            for (let f of frets) {
              let noteIdx = (openIdx + f) % 12;
              let noteOnFret = allNotes[noteIdx];
              if (noteOnFret === n || (showAccidentals && ((sharpNotes.includes(n) && noteOnFret === n) || (flatNotes.includes(n) && allNotes[noteIdx] === n)))) {
                idxs.push(f);
              }
            }
            if (idxs.length > 0) {
              session.push({
                string: s,
                note: n,
                frets: idxs.slice(),
                found: [],
              });
            }
          }
        }
        session = shuffle(session);
        // Replace simple shuffle with weighted shuffle if stats exist, there are mistakes, and bias is enabled
        if (enableBias && statistics.answers.length > 0) {
          const currentTuningStr = JSON.stringify(tuning);
          const mistakeCounts = Array(numStrings).fill(0);
          let totalMistakes = 0;
          statistics.answers.forEach((answer) => {
            if (JSON.stringify(answer.tuning) === currentTuningStr && !answer.correct) {
              mistakeCounts[answer.string]++;
              totalMistakes++;
            }
          });
          const biasStrength = 1; // Adjust this value to increase/decrease bias effect
          if (totalMistakes > 0) {
            const weights = session.map((card) => 1 + (mistakeCounts[card.string] / totalMistakes) * biasStrength);
            session = weightedShuffle(session, weights);
          }
        }
        // Recompute string error counts for the current tuning/session so UI tooltips are correct
        computeStringErrorCounts();
        sessionIdx = 0;
      }

      // Add weighted shuffle function
      function weightedShuffle(arr, weights) {
        const result = [];
        let totalWeight = weights.reduce((sum, w) => sum + w, 0);
        while (arr.length > 0) {
          let rand = Math.random() * totalWeight;
          let cumWeight = 0;
          for (let i = 0; i < arr.length; i++) {
            cumWeight += weights[i];
            if (rand < cumWeight) {
              result.push(arr[i]);
              totalWeight -= weights[i];
              arr.splice(i, 1);
              weights.splice(i, 1);
              break;
            }
          }
        }
        return result;
      }

      function shuffle(a) {
        for (let i = a.length - 1; i > 0; i--) {
          let j = Math.floor(Math.random() * (i + 1));
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      function showCard() {
        clearTimeout(pendingTimeout);
        clearInterval(countdownInterval);
        $("#countdown").text("");
        // Ensure error counts match current tuning/session before rendering
        computeStringErrorCounts();
        if (session.length === 0) {
          $("#quiz-note-btn").text("?");
          // clear machine-readable attributes when no session
          $("#quiz-note-btn").removeAttr("data-note");
          $("#flashcard-string").removeAttr("data-string-index data-string-name data-frets-count");
          $("#flashcard-string").text("Start!");
          $("#fret-buttons").empty();
          $("#fretboard-area").empty();
          $("#note-score").hide();
          return;
        }
        currentCard = session[sessionIdx];
        currentCard.shownTime = Date.now(); // Track when the card is shown
        foundFrets = currentCard.found.slice();
        $("#quiz-note-btn").text(currentCard.note);
        // expose stable attributes for tests (and other tooling)
        $("#quiz-note-btn").attr("data-note", currentCard.note);
        if (showScoreNotation) {
          $("#note-score").show();
          renderNoteScore(currentCard.note, currentCard.string, currentCard.frets);
        } else {
          $("#note-score").hide();
        }
        $("#flashcard-string").attr("data-string-index", currentCard.string).attr("data-string-name", stringNames[currentCard.string].name).attr("data-frets-count", currentCard.frets.length);
        $("#flashcard-string").text(
          // show as a readable sentence: "on the ... string"
          (extendedRange ? stringNames[currentCard.string].name.replace(")", ", " + currentCard.frets.length + "x)") : stringNames[currentCard.string].name) + " string",
        );

        drawFretboardTable(currentCard.string, foundFrets);

        let btns = "";
        for (let f = 0; f < fretCount; f++) {
          let btnClass = "fret-btn";
          if (f === 0) btnClass += " open-fret";
          if (foundFrets.includes(f)) btnClass += " correct";
          btns += `<button class="${btnClass}" data-fret="${f}">${f}</button>`;
        }
        $("#fret-buttons").html(btns);
      }

      let stringErrorCounts = []; // Array to hold error counts per string for current tuning

      // Function to compute error counts per string for the current tuning
      function computeStringErrorCounts() {
        // Determine expected length from current tuning (fallback to numStrings)
        const len = Array.isArray(tuning) && tuning.length ? tuning.length : numStrings;
        stringErrorCounts = Array.from({ length: len }, () => 0);
        const currentTuningStr = JSON.stringify(tuning);
        statistics.answers.forEach((answer) => {
          try {
            if (JSON.stringify(answer.tuning) === currentTuningStr && !answer.correct) {
              const idx = Number(answer.string);
              // Guard: only count valid string indices
              if (Number.isFinite(idx) && idx >= 0 && idx < stringErrorCounts.length) {
                stringErrorCounts[idx]++;
              }
            }
          } catch (e) {
            // ignore malformed entries
          }
        });
      }

      function drawFretboardTable(highlightStringIdx, foundFretsArr) {
        let extraFret = extendedRange ? 0 : 1; // Add extra column for 12th fret marker in default mode (visual only)
        let fretRows = "";
        for (let s = 0; s < stringNames.length; s++) {
          fretRows += `<tr>`;
          // Add title attribute for hover tooltip showing error count (safe fallback to 0)
          const wrongCount = Array.isArray(stringErrorCounts) ? stringErrorCounts[s] || 0 : 0;
          fretRows += `<td class="open-note" title="wrong: ${wrongCount}" data-string="${s}" data-fret="0">${stringNames[s].openNote}</td>`;
          for (let f = 0; f < fretCount + extraFret; f++) {
            let fretClass = "fret-cell";
            if (f === 0) fretClass += " open-fret";
            if (s === highlightStringIdx) {
              fretClass += " active-string";
              if (foundFretsArr.includes(f)) fretClass += " fret-found";
            } else {
              fretClass += " inactive";
            }
            if (f >= fretCount) {
              fretClass += " inactive"; // Extra column is inactive (visual only)
              fretRows += `<td class="${fretClass}" style="visibility: hidden;" data-string="${s}" data-fret="${f}"></td>`;
            } else {
              fretRows += `<td class="${fretClass}" data-string="${s}" data-fret="${f}"></td>`;
            }
          }
          fretRows += `</tr>`;
        }

        // Fret marker row (dots)
        let markRow = '<tr class="fretboard-mark-row">';
        markRow += "<td></td>";
        for (let f = 0; f < fretCount + extraFret; f++) {
          let marker = "";
          let fretNum = f; // 0 = open, 1 = 1st fret, etc.
          if (extendedRange) {
            if (typicalFretMarks.includes(fretNum)) {
              if (doubleFretMarkers.includes(fretNum)) {
                marker = `<span class="fret-dot double">
                        <span class="dot dot1"></span>
                        <span class="dot dot2"></span>
                    </span>`;
              } else {
                marker = `<span class="fret-dot"></span>`;
              }
            }
          } else {
            // Use same logic as extended for consistency, but limit to frets <=12
            if (typicalFretMarks.includes(fretNum) && fretNum <= 12) {
              if (doubleFretMarkers.includes(fretNum)) {
                marker = `<span class="fret-dot double">
                        <span class="dot dot1"></span>
                        <span class="dot dot2"></span>
                    </span>`;
              } else {
                marker = `<span class="fret-dot"></span>`;
              }
            }
          }
          if (f >= fretCount) {
            markRow += `<td class="fret-dot-cell">${marker}</td>`; // Marker visible
          } else {
            markRow += `<td class="fret-dot-cell">${marker}</td>`;
          }
        }
        markRow += "</tr>";

        // Table header row (fret numbers)
        let headerRow = '<tr class="fretboard-header">';
        headerRow += "<th></th>";
        for (let f = 0; f < fretCount + extraFret; f++) {
          if (f >= fretCount) {
            headerRow += `<th class="fret-label" style="visibility: hidden;">${f}</th>`; // Header hidden
          } else {
            headerRow += `<th class="fret-label">${f}</th>`;
          }
        }
        headerRow += "</tr>";

        let tableHtml = `<table class="fretboard-table"><thead>${headerRow}</thead><tbody>${fretRows}${markRow}</tbody></table>`;
        $("#fretboard-area").html(tableHtml);
      }

      function nextCard() {
        sessionIdx++;
        if (sessionIdx >= session.length) {
          alert("Session complete!");
          makeSession();
        }
        showCard();
      }

      function markButton(btn, correct) {
        $(btn).addClass(correct ? "correct" : "wrong");
        if (!correct) setTimeout(() => $(btn).removeClass("wrong"), 1000);
      }

      function handleFretClick(e) {
        if (!currentCard) return;
        let fret = parseInt($(this).attr("data-fret"));
        playAnsweredNote(currentCard.string, fret);
        let isCorrect = currentCard.frets.includes(fret);
        // Record the answer event
        statistics.answers.push({
          tuning: tuning.slice(), // Copy current tuning array
          string: currentCard.string,
          note: currentCard.note,
          userAnswer: fret,
          correct: isCorrect,
          timestamp: Date.now(),
          shownTimestamp: currentCard.shownTime, // Add shown timestamp for response time calculation
        });
        saveStatistics(); // Persist after each event
        computeStringErrorCounts(); // Recompute error counts after answer
        drawFretboardTable(currentCard.string, foundFrets); // Redraw fretboard to update hover tooltips
        if (isCorrect) {
          if (extendedRange) {
            if (!foundFrets.includes(fret)) {
              foundFrets.push(fret);
              currentCard.found = foundFrets.slice();
              markButton($(`.fret-btn[data-fret=${fret}]`), true);
              highlightFretOnFretboard(currentCard.string, fret, true);
            }
            if (foundFrets.length === currentCard.frets.length) {
              doCountdownAndNext();
            }
          } else {
            markButton($(`.fret-btn[data-fret=${fret}]`), true);
            highlightFretOnFretboard(currentCard.string, fret, true);
            doCountdownAndNext();
          }
        } else {
          markButton($(`.fret-btn[data-fret=${fret}]`), false);
          highlightFretOnFretboard(currentCard.string, fret, false);
          playDesiredNote(currentCard.string, currentCard.frets[0]);
        }
      }

      function handleFretboardClick(e) {
        let s = Number($(this).attr("data-string"));
        let f = Number($(this).attr("data-fret"));
        if (s !== currentCard.string) return;
        playAnsweredNote(s, f);
        let isCorrect = currentCard.frets.includes(f);
        // Record the answer event
        statistics.answers.push({
          tuning: tuning.slice(), // Copy current tuning array
          string: currentCard.string,
          note: currentCard.note,
          userAnswer: f,
          correct: isCorrect,
          timestamp: Date.now(),
          shownTimestamp: currentCard.shownTime, // Add shown timestamp for response time calculation
        });
        saveStatistics(); // Persist after each event
        computeStringErrorCounts(); // Recompute error counts after answer
        drawFretboardTable(currentCard.string, foundFrets); // Redraw fretboard to update hover tooltips
        if (isCorrect) {
          if (extendedRange) {
            if (!foundFrets.includes(f)) {
              foundFrets.push(f);
              currentCard.found = foundFrets.slice();
              markButton($(`.fret-btn[data-fret=${f}]`), true);
              highlightFretOnFretboard(currentCard.string, f, true);
            }
            if (foundFrets.length === currentCard.frets.length) {
              doCountdownAndNext();
            }
          } else {
            markButton($(`.fret-btn[data-fret=${f}]`), true);
            highlightFretOnFretboard(currentCard.string, f, true);
            doCountdownAndNext();
          }
        } else {
          markButton($(`.fret-btn[data-fret=${f}]`), false);
          highlightFretOnFretboard(currentCard.string, f, false);
          playDesiredNote(currentCard.string, currentCard.frets[0]);
        }
      }

      function playAnsweredNote(stringIdx, fretIdx) {
        let midi = stringNames[stringIdx].midi + fretIdx;
        let freq = midiToFreq(midi);
        playTone(freq, 0.7);
      }

      function playDesiredNote(stringIdx, fretIdx) {
        let midi = stringNames[stringIdx].midi + fretIdx;
        let freq = midiToFreq(midi);
        setTimeout(() => playTone(freq, 0.7), 250);
      }

      function highlightFretOnFretboard(stringIdx, fretIdx, correct) {
        let selector = `.fret-cell[data-string="${stringIdx}"][data-fret="${fretIdx}"]`;
        console.log("selector", selector);
        let $fret = $(selector);
        if (correct) {
          $fret.removeClass("fret-wrong").addClass("fret-found");
        } else {
          $fret.addClass("fret-wrong");
          setTimeout(() => {
            $fret.removeClass("fret-wrong");
          }, 1000);
        }
      }

      function doCountdownAndNext() {
        clearInterval(countdownInterval);
        if (timeoutSeconds === 0) {
          nextCard();
          return;
        }
        countdownValue = timeoutSeconds;
        $("#countdown").text("⏳ " + countdownValue);
        countdownInterval = setInterval(() => {
          countdownValue--;
          $("#countdown").text(countdownValue > 0 ? "⏳ " + countdownValue : "");
          if (countdownValue <= 0) {
            clearInterval(countdownInterval);
            $("#countdown").text("");
            nextCard();
          }
        }, 1000);
      }

      function playNoteCard() {
        if (!currentCard) return;
        let fret = currentCard.frets[0];
        let midi = stringNames[currentCard.string].midi + fret;
        let freq = midiToFreq(midi);
        playTone(freq, 0.8);
      }

      // New: HTML5 Audio element approach instead of Web Audio API
      let audioElements = {}; // Cache for generated audio elements
      let audioEnabled = false;
      let isIOS = false;

      // Detect iOS devices
      function detectIOS() {
        return /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
      }

      // Generate a WAV data URL for a given frequency
      function generateToneDataURL(freq, duration = 0.8, sampleRate = 44100) {
        const length = Math.floor(sampleRate * duration);
        const buffer = new ArrayBuffer(44 + length * 2);
        const view = new DataView(buffer);

        // WAV header
        const writeString = (offset, string) => {
          for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
          }
        };

        writeString(0, "RIFF");
        view.setUint32(4, 36 + length * 2, true);
        writeString(8, "WAVE");
        writeString(12, "fmt ");
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, 1, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * 2, true);
        view.setUint16(32, 2, true);
        view.setUint16(34, 16, true);
        writeString(36, "data");
        view.setUint32(40, length * 2, true);

        // Compute MIDI and octave from frequency
        const midi = 69 + 12 * Math.log2(freq / 440);
        const octave = Math.floor(midi / 12) - 1;
        const useTriangle = octave === 1 || octave === 2;

        // Generate wave data (triangle for octaves 1-2, sine otherwise)
        for (let i = 0; i < length; i++) {
          let sample;
          if (useTriangle) {
            sample = (4 * Math.abs((((i * freq) / sampleRate) % 1) - 0.5) - 1) * 0.15 * 32767;
          } else {
            sample = Math.sin((2 * Math.PI * freq * i) / sampleRate) * 0.15 * 32767;
          }
          const offset = 44 + i * 2;
          if (offset + 1 < buffer.byteLength) {
            view.setInt16(offset, sample, true);
          }
        }

        const blob = new Blob([buffer], { type: "audio/wav" });
        return URL.createObjectURL(blob);
      }

      // Updated playTone to use HTML5 Audio elements
      function playTone(freq, duration) {
        // On non-iOS devices, ensure audio is initialized
        if (!isIOS && !audioEnabled) {
          audioEnabled = true; // Assume it works on non-iOS
          initAudioContext();
        }

        // For iOS, require explicit enabling
        if (isIOS && !audioEnabled) {
          console.warn("Audio not enabled on iOS - click enable sound banner");
          return;
        }

        try {
          const cacheKey = `${Math.round(freq)}_${duration}`;

          // On iOS, don't reuse cached audio elements to prevent playback conflicts
          // Create a new audio element each time for reliable playback
          let audio;
          if (isIOS || !audioElements[cacheKey]) {
            audio = new Audio();
            try {
              audio.src = generateToneDataURL(freq, duration);
              audio.preload = "auto";
              if (!isIOS) {
                audioElements[cacheKey] = audio; // Only cache on non-iOS
              }
            } catch (err) {
              console.error("Error generating tone:", err);
              return;
            }
          } else {
            audio = audioElements[cacheKey];
          }

          // For non-iOS cached elements, reset position
          if (!isIOS) {
            audio.currentTime = 0;
          }

          const playPromise = audio.play();

          if (playPromise !== undefined) {
            playPromise
              .then(() => {
                console.log("Audio played successfully");
              })
              .catch((err) => {
                console.error("Error playing audio:", err);
                // On first failure, try to re-enable audio
                if (!isIOS) {
                  setTimeout(() => initAudioContext(), 100);
                }
              });
          }
        } catch (err) {
          console.error("Error playing tone:", err);
        }
      }

      // Add debounce function for saving timeout
      let timeoutSaveDebounce = null;
      function debouncedSaveTimeout() {
        clearTimeout(timeoutSaveDebounce);
        timeoutSaveDebounce = setTimeout(() => {
          let v = parseInt($("#timeout-seconds").val());
          if (isNaN(v) || v < 0 || v > 10) v = 2;
          timeoutSeconds = v;
          saveSettings();
        }, 200);
      }

      // Function to update the tuning UI
      function updateTuningUI() {
        let html = '<div class="tuning-container">';
        for (let i = 0; i < numStrings; i++) {
          let noteOptions = allNotes.map((n) => `<option value="${n}" ${tuning[i].note === n ? "selected" : ""}>${n}</option>`).join("");
          let octaveOptions = "";
          for (let oct = 0; oct <= 8; oct++) {
            octaveOptions += `<option value="${oct}" ${tuning[i].octave === oct ? "selected" : ""}>${oct}</option>`;
          }
          html += `<div class="string-config">
            <div class="string-label">String ${i + 1}:</div>
            <div class="string-controls">
              <div class="control-row">
                <span>Note:</span>
                <select class="tuning-select" data-string="${i}">${noteOptions}</select>
              </div>
              <div class="control-row">
                <span>Octave:</span>
                <select class="octave-select" data-string="${i}">${octaveOptions}</select>
              </div>
            </div>
          </div>`;
        }
        html += "</div>";
        $("#tuning-config").html(html);
      }

      // Initialize audio - create test sound to enable audio context
      function initAudioContext() {
        try {
          // Create a short silent audio element and play it
          const testAudio = new Audio();
          testAudio.src =
            "data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmQfCjuP2O/Qfi8HI3/A7tqPQQkSUbDn56ZSFAk+ltztw2QfCTuN2bC/";

          const playPromise = testAudio.play();
          if (playPromise !== undefined) {
            playPromise
              .then(() => {
                audioEnabled = true;
                if (isIOS) updateSoundBanner();
                testAudio.pause();
                testAudio.currentTime = 0;
                console.log("Audio enabled successfully");
              })
              .catch((err) => {
                // Suppress expected autoplay policy warnings on desktop
                if (!isIOS && err.name === "NotAllowedError") {
                  // This is expected on desktop - audio will work after user interaction
                  audioEnabled = true;
                } else {
                  console.error("Failed to enable audio:", err);
                  if (isIOS) {
                    audioEnabled = false;
                  } else {
                    // On non-iOS, assume audio will work even if test fails
                    audioEnabled = true;
                  }
                }
              });
          } else {
            // Fallback for older browsers
            audioEnabled = true;
          }
        } catch (err) {
          console.error("Failed to initialize audio:", err);
          if (!isIOS) {
            // On non-iOS, assume audio will work
            audioEnabled = true;
          }
        }
      }

      function updateSoundBanner() {
        const banner = $("#sound-banner");
        if (audioEnabled) {
          banner.addClass("enabled").text("🔊 Sound enabled!");
          setTimeout(() => banner.hide(), 2000);
        } else {
          banner.removeClass("enabled").text("🔊 Click here to enable sound").show();
        }
      }

      $(function () {
        // Detect iOS and show banner if needed
        isIOS = detectIOS();
        if (isIOS) {
          $("#sound-banner").show();
          // Don't auto-initialize on iOS - require user action
        } else {
          // On non-iOS devices, initialize audio automatically
          audioEnabled = true;
          initAudioContext();
        }

        loadSettings();
        loadStatistics(); // Load stats on init (now includes computeStringErrorCounts)
        updateTuningUI(); // Initialize tuning UI
        makeSession();
        showCard();

        $("#fret-buttons").on("click", ".fret-btn", handleFretClick);

        $("#quiz-note-btn").on("click", function () {
          playNoteCard();
        });

        $("#extended-range").on("change", function () {
          extendedRange = this.checked;
          saveSettings();
          makeSession();
          showCard();
        });
        $("#accidentals").on("change", function () {
          showAccidentals = this.checked;
          saveSettings();
          makeSession();
          showCard();
        });
        $("#timeout-seconds").on("change", function () {
          let v = parseInt(this.value);
          timeoutSeconds = isNaN(v) ? 2 : v;
          saveSettings();
        });
        $("#timeout-seconds").on("keypress", debouncedSaveTimeout);

        $("#fretboard-area").on("click", ".fret-cell.active-string", handleFretboardClick);

        // Add event handler for open string note clicks
        $("#fretboard-area").on("click", ".open-note", function () {
          let stringIdx = parseInt($(this).attr("data-string"));
          playAnsweredNote(stringIdx, 0); // Play the open string (fret 0)
        });

        // Add event handler for number of strings change
        $("#num-strings").on("change", function () {
          numStrings = parseInt(this.value);
          tuning = defaultTunings[numStrings].strings.slice(); // Reset to default tuning for new count
          updateTuningUI();
          saveSettings();
          makeSession();
          showCard();
        });

        // Add event handler for individual tuning changes
        $("#tuning-config").on("change", ".tuning-select", function () {
          let stringIdx = $(this).data("string");
          tuning[stringIdx].note = this.value;
          saveSettings();
          makeSession();
          showCard();
        });

        // Add event handler for octave changes
        $("#tuning-config").on("change", ".octave-select", function () {
          let stringIdx = $(this).data("string");
          tuning[stringIdx].octave = parseInt(this.value);
          saveSettings();
          makeSession();
          showCard();
        });

        // Add event handler for reset button
        $("#reset-tuning").on("click", function () {
          numStrings = 6;
          $("#num-strings").val(6);
          tuning = defaultTunings[6].strings.slice();
          updateTuningUI();
          saveSettings();
          makeSession();
          showCard();
        });

        // Add event handler for reset stats button
        $("#reset-stats").on("click", function () {
          statistics = { answers: [] };
          saveStatistics();
        });

        // Sound banner click handler (only needed on iOS)
        $("#sound-banner").on("click", function () {
          initAudioContext();
        });

        $("#enable-bias").on("change", function () {
          enableBias = this.checked;
          saveSettings();
          // Do not recreate session or change current card; bias applies to next makeSession()
        });

        $("#show-score-notation").on("change", function () {
          showScoreNotation = this.checked;
          saveSettings();
          if (showScoreNotation) {
            $("#score-key-row").show();
          } else {
            $("#score-key-row").hide();
          }
          showCard();
        });

        $("#score-key").on("change", function () {
          scoreKey = this.value;
          saveSettings();
          showCard();
        });

        // Add event handler for skip button
        $("#skip-countdown").on("click", function () {
          clearInterval(countdownInterval);
          countdownValue = 0;
          $("#countdown").text("");
          nextCard();
        });
      });
    </script>
  </body>
</html>
